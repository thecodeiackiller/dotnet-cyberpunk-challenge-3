using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using dotnet_cyberpunk_challenge_3.malware.lib;
using dotnet_cyberpunk_challenge_3.malware.lib._lib;


namespace dotnet_cyberpunk_challenge_3.malware
{
    /*
        TODO: Challenge2 - Tasks
            1. FIRST, You'll need to go to `MultiKuangMalwareFamily.cs` and do the tasks listed there, then come back
            
            2. Okay, if you already finished the `MultiKuangMalwareFamily.cs` then you're good to continue!
            
            3. Swap the base class to use MultiKuangDaemonFamilyBase

            4. Pass in the generic types that we need to the base class. You'll need to look in `_HttpResponseModels.cs`
            and use what you know to pick the right classes.
            Couple things to remember to do right: 
                - It expects two classes to be passed in
                - You're working with Arasaka in this class. Look at the classes you find in `_HttpResponseModels.cs`
                - Remember that the `where T : SomeClass` constraint you added in `MultiKuangDaemonFamilyBase` limits which
                classes you can pass to the base class. 
                - Where you might have `where T : MessageRoot` means that you need to pass in the Arasaka class 
                that inherits from `MessageRoot`.
                - Apply the same concepts to get the right class passed in to the second placeholder (probably named Z)
            
            5. Inside of `Initialize()` you need to change `GetCurrentArasakaConnection()` to be `GetCurrentConnection()`

            6. Change the method definition of `GetArasakaProcessList()` to be `_GetProcessList() and set the access modifier to `protected`

            7. Inside `GetProcessMemoryMapping()` we need to change the `GetArasakaProcessList()` to be `GetProcessList()`

            6. You're done here! Go back to `Handler.cs`
    */
    {
        public async override Task Initialize()
        {
            // TODO: Use F12 to go to this method's defintion
            await GetCurrentArasakaConnection();
        }
    
        public async override Task<string> GetIceTypeOnRemote()
        {
            ArasakaMessageRoot arasakaMessageResponse = await CurrentServerConnection.SendRequest("model-type");
            string modelType = arasakaMessageResponse.content.model;

            string matchedModel = "";
            if (_IsTargetHatichiICE(modelType)){
                matchedModel = "hatachi";
            } else if (_IsTargetHosakaICE(modelType)) {
                matchedModel ="hosaka";
            } else if (_IsTargetKiroshiICE(modelType)) {
                matchedModel = "kiroshi";
            } else {
                matchedModel = "unknown";
            }

            return matchedModel; 
        }

        public async override Task<List<ArasakaMessageProcessList>> GetArasakaProcessList()
        {
            ArasakaMessageRoot message = await CurrentServerConnection.SendRequest("process-list");
            List<ArasakaMessageProcessList> processList = message.content.processList;
            return processList;
        }


        public async override void IceBreak()
        {
            throw new NotImplementedException();
        }


        // FIXME: DON'T CHANGE - This is still under development
        public async override Task SetupIceBreakerTunnelToTarget()
        {
            // CurrentIceBreakerTunnelConnection  = new CurrentIceBreakerTunnelConnection();
            // await CurrentIceBreakerTunnelConnection .Initialize();
        }

        public async override Task<IEnumerable<string>> GetProcessMemoryMapping()
        {
            List<ArasakaMessageProcessList> arasakaMessageProcessLists = await GetArasakaProcessList();
            return arasakaMessageProcessLists.Select(pl => pl.memoryStartingAddress);
        }
    }
}