using System;
using System.Collections.Generic;
using System.ComponentModel.Design;
using System.Linq;
using System.Threading.Tasks;
using dotnet_cyberpunk_challenge_3.malware.lib;
using dotnet_cyberpunk_challenge_3.malware.lib._lib;

namespace dotnet_cyberpunk_challenge_3.malware
{

    /*
        TODO: Challenge3 - Tasks
            1. First we need to fix how the generics work with this class. This is a little similar to
            what you did in the `MultiKuangMalwareFamily` for challenge2.
            Notice that T and Z are already being passed to the base class. Where are they being passed *from*?
                - We need to put a T and Z in the `<>` for this class; it will be "passed" to the base class as well

            2. Like we did in challenge2 we need to set the `where` type constraints correctly. Remember 
            this should look like `where T : SomeClass`. The spacing format of the `where` statements on two lines
            is just for readability. You'll need to match the same `where` constraints that you used in the
            base class. FYI This is going to allow the code to infer how you're gonna use the types throughout
            this file.
                - Check what the `where` statements say in the base class. You'll use the same constraints

            3. Since this class was inspired by the Arasaka Kuang variant malware there are mentions of
            `ArasakaMessageRoot`. 
                - Please check for where you can replace `ArasakaMessageRoot` with `T`
                - Notice that there are conditional blocks that are checking "if T is MilitechMessageRoot"
                or "if T is ArasakaMessageRoot"; we DON'T want to change how those conditionals work so keep
                your eyes peeled!
                - There are some variables that are declared with type `ArasakaMessageRoot`. These are probably
                good to change to T.

            4. Go back to Handler.cs
    */
    public class MultiKuangPrimusMalware<T,Z> : MultiKuangDaemonFamilyBase<T, Z>
        where T : MessageRoot
        where Z : ProcessList
    {
        public async override Task<string> GetIceTypeOnRemote()
        {
            // FIXME: Would be cool to have them figure this out
            T messageResponse = await CurrentServerConnection.SendRequest("model-type");
            string modelType = "";
            
            if (typeof(T) == typeof(MilitechMessageRoot)) {
                modelType = (messageResponse as MilitechMessageRoot).connection.model;
            } else if (typeof(T) == typeof(BiotechnicaMessageRoot)) {
                modelType = (messageResponse as BiotechnicaMessageRoot).content.model;
            } else if (typeof(T) == typeof(BiotechnicaMessageRoot))
            {
                modelType = (messageResponse as BiotechnicaMessageRoot).connection.model;
            }
            else {
                throw new NotImplementedException();
            }

            string matchedModel = "";
            if (_IsTargetHatichiICE(modelType)){
                matchedModel = "hatachi";
            } else if (_IsTargetHosakaICE(modelType)) {
                matchedModel ="hosaka";
            } else if (_IsTargetKiroshiICE(modelType)) {
                matchedModel = "kiroshi";
            } else {
                matchedModel = "unknown";
            }

            return matchedModel; 
        }

        public async override Task<IEnumerable<string>> GetProcessMemoryMapping()
        {
            List<Z> messageProcessLists = await GetProcessList();
            return messageProcessLists.Select(pl => pl.memoryStartingAddress);
        }

        protected async override Task<List<Z>> _GetProcessList() {
            T message = await CurrentServerConnection.SendRequest("process-list");
            if (typeof(Z) == typeof(MilitechICEProcessList)) {
                List<MilitechICEProcessList> processList = (message as MilitechMessageRoot).connection.processList;
                return processList as List<Z>;
            } else if (typeof(Z) == typeof(ArasakaMessageProcessList)) {
                List<ArasakaMessageProcessList> processList = (message as BiotechnicaMessageRoot).content.processList;
                return processList as List<Z>;
            }
            else if (typeof(Z) == typeof(BiotechnicaProcessList)) {
                List<BiotechnicaProcessList> processList = (message as BiotechnicaMessageRoot).connection.processList;
                return processList as List<Z> ;
            }
            else {
                throw new NotImplementedException();
            }

        }

        public override void IceBreak()
        {
            throw new NotImplementedException();
        }

        public async override Task Initialize()
        {
            await GetCurrentConnection();
        }

        public async override Task SetupIceBreakerTunnelToTarget()
        {
            CurrentIceBreakerTunnelConnection = new IceBreakerTunnelConnection<T>();
            await CurrentIceBreakerTunnelConnection.Initialize();
        }
    }
}