using dotnet_cyberpunk_challenge_3.malware.lib._lib;

namespace dotnet_cyberpunk_challenge_3.malware.lib
{
    

    public abstract class KuangDaemonFamilyBase<T> where T : new()
    {
        protected bool IsConnectionTunnelProtected {get;set;}
        protected bool IsConnectionProxyEnabled {get;set;}
        // public ArasakaServerConnection CurrentArasakaServerConnection {get;set;}
        // public MilitechServerConnection CurrentMilitechServerConnection {get;set;}
        
        // TODO: You need to change the type of CurrentServerConnection to use the Generic type placeholder of the class
        public ArasakaServerConnection CurrentServerConnection {get;set;}
        public IceBreakerArasakaTunnelConnection CurrentIceBreakerArasakaTunnelConnection {get;set;}
        public IceBreakerMilitechTunnelConnection CurrentIceBreakerMilitechTunnelConnection {get;set;}



        public abstract Task SetupIceBreakerTunnelToTarget(); // Setup the connection tunnel between host and target

        public abstract Task<string> GetIceTypeOnRemote(); // Students need to Get type of ICE on target

        public abstract void IceBreak(); // Students need to Attempt to Break the ICE

        public abstract Task Initialize();

        public virtual Task<List<ArasakaMessageProcessList>> GetArasakaProcessList() {
            throw new NotImplementedException();
        }

        public virtual Task<List<MilitechICEProcessList>> GetMilitechProcessList() {
            throw new NotImplementedException();
        }

        public abstract Task<IEnumerable<string>> GetProcessMemoryMapping(); 



        public async virtual Task<ArasakaServerConnection> GetCurrentArasakaConnection() {
            /*
                TODO: Great you made it! Couple things we need to do:
                    1. Change the return type of this method to return a Task of T
                    2. The CurrentServerConnection is currently set as an ArasakaServerConnection.
                    We need to change this to be generic. Find the definition above of CurrentServerConnection
                    and change the type of that property to be T
                    3. While this method name implies that we are going to Get an Arasaka Connection 
                    the code doesn't actually reflect that yet. Since this method doesn't know that 
                    T is going to be an `ArasakaServerConnection` or `MilitechServerConnection` it doesn't 
                    know where the `Initialize()` actually is. For that reason we need to "treat" it as
                    ArasakaServerConnection and call the `.Initialize()`:
                        - Change the `await` line to  `await (<your-object> as ArasakaServerConnection).Initialize()`
            */
            try {
                if (CurrentServerConnection != null) {
                    return CurrentServerConnection;
                } else {
                    throw new Exception("Not Currently connected to an Arasaka Server! Hope your synapses aren't burnt out.");
                }
            } catch {
                CurrentServerConnection = _EstablishConnectionToTargetServer();
                await CurrentServerConnection.Initialize();
                return CurrentServerConnection;
            }
        }

        public async virtual Task<MilitechServerConnection> GetCurrentMilitechConnection() {
            /*
                TODO: Again - Great you made it! Couple things we need to do:
                    1. Change the return type of this method to return a Task of T
                    2. The CurrentServerConnection is already of type T. When we attempt to Initialize it
                    we need to treat the CurrentServerConnection object as a MilitechServerConnection
                    so we can call the `Initialize()`
            */
            try {
                if (CurrentServerConnection != null) {
                    return CurrentServerConnection;
                } else {
                    throw new Exception("Not Currently connected to an Arasaka Server! Hope your synapses aren't burnt out.");
                }
            } catch {
                CurrentServerConnection = _EstablishConnectionToTargetServer();

                // TODO: We need to treat this object as a MilitechServerConnection to use `.Initialize()`
                // HINT: Check what you did for `GetCurrentAraskaConnection()`
                await CurrentServerConnection.Initialize();
                return CurrentServerConnection;
            }
        }



        protected virtual bool _IsTargetHatichiICE(string retrievedModelType){
            return KnownIceTypes.HITACHI == retrievedModelType;
        }

        protected virtual bool _IsTargetHosakaICE(string retrievedModelType){
            return KnownIceTypes.HOSAKA == retrievedModelType;
        }

        protected virtual bool _IsTargetKiroshiICE(string retrievedModelType){
            return KnownIceTypes.KIROSHI == retrievedModelType;
        }

        protected virtual T _EstablishConnectionToTargetServer() {
            // DO NOT CHANGE
            // This also relies on the `where T : new ()` as well
            return new T();
        }

        protected async virtual Task<IceBreakerArasakaTunnelConnection> _EncryptArasakaConnection() {
            IceBreakerArasakaTunnelConnection tunnel = new IceBreakerArasakaTunnelConnection();
            await tunnel.Initialize();
            IsConnectionTunnelProtected = tunnel.IsEncrypted == true && tunnel.TunnelEncryption == EncryptionType.SSL;
            IsConnectionProxyEnabled = tunnel.IsEncrypted;
            return tunnel;
        }

        protected async virtual Task<IceBreakerMilitechTunnelConnection> _EncryptMilitechConnection() {
            IceBreakerMilitechTunnelConnection tunnel = new IceBreakerMilitechTunnelConnection();
            await tunnel.Initialize();
            IsConnectionTunnelProtected = tunnel.IsEncrypted == true && tunnel.TunnelEncryption == EncryptionType.SSL;
            IsConnectionProxyEnabled = tunnel.IsEncrypted;
            return tunnel;
        }
    }
}