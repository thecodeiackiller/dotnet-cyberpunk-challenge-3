using dotnet_cyberpunk_challenge_3.malware.lib._lib;
using dotnet_cyberpunk_challenge_3.malware.lib._lib.interfaces;

namespace dotnet_cyberpunk_challenge_3.malware.lib
{
    /*
        TODO: Challenge2 - Tasks

            1. First you'll need to set two generic type 'placeholders' on this class `MultiKuangDaemonFamilyBase` inside the `<>`.
            I would normally use T and Z but it's up to you. Whatever you choose needs to be consistent within this file.
            
            2. Next you need to set the `where` type constraints correctly. If you used `<T, Z>` for your
            placeholders then this would look like `where T : SomeClass`. The line format here is just for
            readability. You'll need to look at `_HttpResponseModels.cs` and find a base class that both
            `ArasakaMessageRoot` and `MilitechMessageRoot` inherit from and replace the first 
            `<INSERT TYPE>` with that base class.
`
            3. You need to do the same as in step 2 for your second placeholder (where I'd normally use Z)
            except you need to find a base class that `ArasakaMessageProcessList` and `MilitechICEProcessList`
            inhert from and replace `<INSERT TYPE>` with that base class.

            4. Everywhere in this file that uses the `ArasakaMessageRoot` or `MilitechMessageRoot` needs to
            be replaced with `T` or whatever the first placeholder is that you used.

            5. Everything in this file that uses `ArasakaMessageProcessList` or `MilitechICEProcessList`
            needs to be replaced with `Z` or whatever the first placeholder is that you used.

            6. You're done! Go back to `ArasakaKuangPrimusMalware`, unless you were previously at `MilitechKuangPrimusMalware`
            in which case just go there.
    */
    public abstract class MultiKuangDaemonFamilyBase<T,Z> // Need to set two generic type placeholders on this class.
        where T : MessageRoot // TODO: This should be in the form of `where PLACEHOLDER : SomeClass`
        where Z: ProcessList
    {
        protected bool IsConnectionTunnelProtected {get;set;}
        protected bool IsConnectionProxyEnabled {get;set;}
        public ServerConnection<T> CurrentServerConnection {get;set;}
        public IceBreakerTunnelConnection<T> CurrentIceBreakerTunnelConnection {get;set;}



        public abstract Task SetupIceBreakerTunnelToTarget(); // Setup the connection tunnel between host and target

        public abstract Task<string> GetIceTypeOnRemote(); // Students need to Get type of ICE on target

        public abstract void IceBreak(); // Students need to Attempt to Break the ICE

        public abstract Task Initialize();
        
        protected abstract Task<List<Z>> _GetProcessList();

        // FIXME: Mentor note - This be cool spot to teach them about why protected method abstraction is cool
        public async Task<List<Z>> GetProcessList() {
            return await _GetProcessList();
        }

        public abstract Task<IEnumerable<string>> GetProcessMemoryMapping(); 



        public async virtual Task<ServerConnection<T>> GetCurrentConnection() {
            try {
                if (CurrentServerConnection != null) {
                    return CurrentServerConnection;
                } else {
                    throw new Exception("Not Currently connected to an Arasaka Server! Hope your synapses aren't burnt out.");
                }
            } catch {
                CurrentServerConnection = _EstablishConnectionToTargetServer();
                await CurrentServerConnection.Initialize();
                return CurrentServerConnection;
            }
        }

        protected virtual bool _IsTargetHatichiICE(string retrievedModelType){
            return KnownIceTypes.HITACHI == retrievedModelType;
        }

        protected virtual bool _IsTargetHosakaICE(string retrievedModelType){
            return KnownIceTypes.HOSAKA == retrievedModelType;
        }

        protected virtual bool _IsTargetKiroshiICE(string retrievedModelType){
            return KnownIceTypes.KIROSHI == retrievedModelType;
        }

        protected virtual ServerConnection<T> _EstablishConnectionToTargetServer() {
            // return new ArasakaServerConnection();
            return new ServerConnection<T>();
        }


        // FIXME: This needs genericized. Suspect it needs to use concrete classes (which requires
        // refactoring class hierarchy
        protected async virtual Task<IceBreakerTunnelConnection<T>> _EncryptConnection(IceBreakerTunnelConnection<T> tunnel) {
            await tunnel.Initialize();
            IsConnectionTunnelProtected = tunnel.IsEncrypted == true && tunnel.TunnelEncryption == EncryptionType.SSL;
            IsConnectionProxyEnabled = tunnel.IsEncrypted;
            return tunnel;
        }
    }
}