using dotnet_cyberpunk_challenge_3.malware.lib._lib;

namespace dotnet_cyberpunk_challenge_3.malware.lib
{
    

    public abstract class KuangDaemonFamilyBase<T> where T : new()
    {
        protected bool IsConnectionTunnelProtected {get;set;}
        protected bool IsConnectionProxyEnabled {get;set;}
        // public ArasakaServerConnection CurrentArasakaServerConnection {get;set;}
        // public MilitechServerConnection CurrentMilitechServerConnection {get;set;}

        public T CurrentServerConnection { get; set; }
        // Had to define CurrentServerConnection as generic type

        // TODO: Challenge1 - You need to change the type of CurrentServerConnection to use the Generic type placeholder of the class
        // - Assuming you did that you can go back to `GetCurrentArasakaConnection`
        public IceBreakerArasakaTunnelConnection CurrentIceBreakerArasakaTunnelConnection {get;set;}
        public IceBreakerMilitechTunnelConnection CurrentIceBreakerMilitechTunnelConnection {get;set;}



        public abstract Task SetupIceBreakerTunnelToTarget(); // Setup the connection tunnel between host and target

        public abstract Task<string> GetIceTypeOnRemote(); // Students need to Get type of ICE on target

        public abstract void IceBreak(); // Students need to Attempt to Break the ICE

        public abstract Task Initialize();

        public virtual Task<List<ArasakaMessageProcessList>> GetArasakaProcessList() {
            throw new NotImplementedException();
        }

        public virtual Task<List<MilitechICEProcessList>> GetMilitechProcessList() {
            throw new NotImplementedException();
        }

        public abstract Task<IEnumerable<string>> GetProcessMemoryMapping(); 



        public async virtual Task<T> GetCurrentArasakaConnection() {
            /*
                TODO: Challenge1 - Great you made it! Couple things we need to do:
                    1. Change the return type of this method to return a Task of T
                    
                    2. The CurrentServerConnection is currently set as an ArasakaServerConnection.
                    We need to change this to be generic, *hint* you can F12 into it or Find 
                    the definition above of CurrentServerConnection and change the type of
                    that property to be T

                    3. While this method name implies that we are going to Get an Arasaka Connection 
                    the code doesn't actually reflect that yet. Since this method doesn't know that 
                    T is going to be an `ArasakaServerConnection` or `MilitechServerConnection` it doesn't 
                    know where the `Initialize()` method actually exists. For that reason we need to
                    "treat" it as ArasakaServerConnection and call the `.Initialize()`:
                        - Change the `await` line to  `await (<your-object> as ArasakaServerConnection).Initialize()`

                    4. You can go back to `Handler.cs` to continue or simply go down to `GetCurrentMilitechConnection`
            */
            try {
                if (CurrentServerConnection != null) {
                    return CurrentServerConnection;
                } else {
                    throw new Exception("Not Currently connected to an Arasaka Server! Hope your synapses aren't burnt out.");
                }
            } catch {
                CurrentServerConnection = _EstablishConnectionToTargetServer();
                await (CurrentServerConnection as ArasakaServerConnection).Initialize(); // Right now, this is bad practice. Casting over and over again is dangerous, so this is where generics eventually come in.
                return CurrentServerConnection;
            }
        }

        public async virtual Task<T> GetCurrentMilitechConnection() {
            /*
                TODO: Challenge1 - Again, Great you made it! Couple things we need to do:
                    1. Change the return type of this method to return a Task of T
                    
                    2. The CurrentServerConnection *should* already of type T. When we attempt to Initialize it
                    we need to treat the CurrentServerConnection object as a `MilitechServerConnection`
                    so we can call the `Initialize()`, otherwise C# doesn't know where `Initialize()` actually
                    exists.
                        - *hint*: How did you tackle this in `GetCurrentArasakaConnection()`?

                    3. You're done here so go back to `Handler.cs`
            */
            try {
                if (CurrentServerConnection != null) {
                    return CurrentServerConnection;
                } else {
                    throw new Exception("Not Currently connected to an Arasaka Server! Hope your synapses aren't burnt out.");
                }
            } catch {
                CurrentServerConnection = _EstablishConnectionToTargetServer();

                // TODO: We need to treat this object as a MilitechServerConnection to use `.Initialize()`
                // HINT: Check what you did for `GetCurrentAraskaConnection()`
                await (CurrentServerConnection as MilitechServerConnection).Initialize(); // Again, bad practice. This is where generics come in so why can use the method initialize for different specified types such as ArasakaServerConnection and MilitechServerConnection
                return CurrentServerConnection;
            }
        }



        protected virtual bool _IsTargetHatichiICE(string retrievedModelType){
            return KnownIceTypes.HITACHI == retrievedModelType;
        }

        protected virtual bool _IsTargetHosakaICE(string retrievedModelType){
            return KnownIceTypes.HOSAKA == retrievedModelType;
        }

        protected virtual bool _IsTargetKiroshiICE(string retrievedModelType){
            return KnownIceTypes.KIROSHI == retrievedModelType;
        }

        protected virtual T _EstablishConnectionToTargetServer() {
            // DO NOT CHANGE
            // This also relies on the `where T : new ()` as well
            return new T();
        }

        protected async virtual Task<IceBreakerArasakaTunnelConnection> _EncryptArasakaConnection() {
            IceBreakerArasakaTunnelConnection tunnel = new IceBreakerArasakaTunnelConnection();
            await tunnel.Initialize();
            IsConnectionTunnelProtected = tunnel.IsEncrypted == true && tunnel.TunnelEncryption == EncryptionType.SSL;
            IsConnectionProxyEnabled = tunnel.IsEncrypted;
            return tunnel;
        }

        protected async virtual Task<IceBreakerMilitechTunnelConnection> _EncryptMilitechConnection() {
            IceBreakerMilitechTunnelConnection tunnel = new IceBreakerMilitechTunnelConnection();
            await tunnel.Initialize();
            IsConnectionTunnelProtected = tunnel.IsEncrypted == true && tunnel.TunnelEncryption == EncryptionType.SSL;
            IsConnectionProxyEnabled = tunnel.IsEncrypted;
            return tunnel;
        }
    }
}